"use strict";

const _ = require("lodash");
const validatorUtil = require("../../utils/validatorUtil");
const helper = require("../../utils/helper");
const errorHelper = require("../../utils/errors");
const fs = require("fs");
const prestoHelper = require("../../utils/presto_helper");
const path = require("path");
const uuidv4 = require("uuidv4").uuid;
const os = require("os");

// An exact copy of the the model definition that comes from the .json file
const definition = <%- definition -%>;
const DataLoader = require("dataloader");
/**
 * module - Creates a class to administer model
 */
module.exports = class <%- nameLc -%> {
  constructor(input) {
    for (let key of Object.keys(input)) {
      this[key] = input[key];
    }
  }
  
  get storageHandler() {
    return <%- nameLc -%>.storageHandler;
  }

  /**
   * name - Getter for the name attribute
   *
   * This attribute is needed by the models' index
   * @return {string} The name of the model
   */
  static get name() {
    return "<%- nameLc -%>";
  }

  /**
   * Cast JSON string to array for the validation.
   * @param  {object} record  Record with JSON string if necessary.
   * @return {object}         Parsed data record.
   */
  static postReadCast(record) {
    if (!record) {
      return [];
    }
    const column_index = {};
    record[0].map((obj, index) => {
      column_index[obj.name] = index;
    });

    let result = [];
    for (const item of record[1]) {
      let record = {};
      for (const attr in definition.attributes) {
        const type = definition.attributes[attr].replace(/\s+/g, "");
        if (
          type[0] === "[" &&
          item[column_index[attr]] !== undefined &&
          item[column_index[attr]] !== null
        ) {
          record[attr] = JSON.parse(item[column_index[attr]]);
        } else if (type === "DateTime") {
          record[attr] = new Date(item[column_index[attr]]).toISOString();
        } else {
          record[attr] = item[column_index[attr]];
        }
      }
      result.push(record);
    }
    return result;
  }

  <% if (useDataLoader) {%>/**
    * Batch function for readById method.
    * @param  {array} keys  keys from readById method
    * @return {array}       searched results
    */
   static async batchReadById(keys) {
     let queryArg = {
       operator: "in",
       field: <%- nameLc -%>.idAttribute(),
       value: keys.join(),
       valueType: "Array",
     };
     let cursorRes = await <%- nameLc -%>.readAllCursor(queryArg);
     cursorRes = cursorRes.<%- namePl -%>.reduce(
       (map, obj) => ((map[obj[<%- nameLc -%>.idAttribute()]] = obj), map),
       {}
     );
     return keys.map(
       (key) =>
         cursorRes[key] || new Error(`Record with ID = "${key}" does not exist`)
     );
   }
 
   static readByIdLoader = new DataLoader(<%- nameLc -%>.batchReadById, {
     cache: false,
   });

   /**
   * readById - The model implementation for reading a single record given by its ID
   *
   * This method is the implementation for reading a single record for the trino storage type, based on SQL.
   * @param {string} id - The ID of the requested record
   * @return {object} The requested record as an object with the type <%- nameLc -%>, or an error object if the validation after reading fails
   * @throws {Error} If the requested record does not exist
   */
   static async readById(id) {
     return await <%- nameLc -%>.readByIdLoader.load(id);
   }<% } else 
  {%>/**
   * readById - The model implementation for reading a single record given by its ID
   *
   * This method is the implementation for reading a single record for the trino storage type, based on SQL.
   * @param {string} id - The ID of the requested record
   * @return {object} The requested record as an object with the type <%- nameLc -%>, or an error object if the validation after reading fails
   * @throws {Error} If the requested record does not exist
   */
  static async readById(id) {
    const query = `SELECT * FROM <%- namePl -%> WHERE ${this.idAttribute()} = '${id}'`;
    let item = null;
    try {
      const client = await this.storageHandler;
      item = await prestoHelper.queryData(query, client);

      if (!item) {
        throw new Error(`Record with ID = "${id}" does not exist`);
      }
    } catch (e) {
      throw new Error(e);
    }
    item = <%- nameLc -%>.postReadCast(item)[0];
    return validatorUtil.validateData("validateAfterRead", this, item);
  }<%}-%>  

  /**
   * countRecords - The model implementation for counting the number of records, possibly restricted by a search term
   *
   * This method is the implementation for counting the number of records that fulfill a given condition, or for all records in the table,
   * for the trino storage type, based on SQL.
   * @param {object} search - The search term that restricts the set of records to be counted - if undefined, all records in the table
   * @param {BenignErrorReporter} benignErrorReporter can be used to generate the standard
   * @return {number} The number of records that fulfill the condition, or of all records in the table
   */
  static async countRecords(search, benignErrorReporter) {
    const whereOptions = prestoHelper.searchConditionsToTrino(
      search,
      definition
    );
    const query = `SELECT COUNT(*) AS num FROM <%- namePl -%> ${whereOptions}`;
    let num = null;
    try {
      const client = await this.storageHandler;
      const result = await prestoHelper.queryData(query, client);
      num = result[1][0][0];
    } catch (e) {
      throw new Error(e);
    }
    return num;
  }

  /**
   * readAll - Limit-offset based pagination is not offered by Trino, and this method is left here only as information
   * to the user / developer. Use *readAllCursor* instead, which relies on cursor based pagination.
   * @throw {Error} If this method is used at all, an Error is thrown
   */
  static async readAll(search, order, pagination, benignErrorReporter) {
    //use default BenignErrorReporter if no BenignErrorReporter defined
    benignErrorReporter = errorHelper.getDefaultBenignErrorReporterIfUndef(
      benignErrorReporter
    );
    // build the whereOptions for limit-offset-based pagination
    const whereOptions = prestoHelper.searchConditionsToTrino(
      search,
      definition
    );
    const orderOptions = prestoHelper.orderConditionsToTrino(
      order,
      this.idAttribute(),
      true
    );

    const limit = pagination.limit;
    const offset = pagination.offset ? pagination.offset : 0;

    let query = `SELECT * FROM (SELECT row_number() over() AS rn, * FROM trino_doctors) `;
    query +=
      whereOptions !== ""
        ? `${whereOptions} AND (rn BETWEEN ${offset + 1} AND ${offset + limit})`
        : `WHERE rn BETWEEN ${offset + 1} AND ${offset + limit}`;
    query += ` ${orderOptions}`;
    let result = null;
    try {
      const client = await this.storageHandler;
      result = await prestoHelper.queryData(query, client);
    } catch (e) {
      throw new Error(e);
    }
    result = <%- nameLc -%>.postReadCast(result);

    return validatorUtil.bulkValidateData(
      "validateAfterRead",
      this,
      result,
      benignErrorReporter
    );
  }

  /**
   * readAllCursor - The model implementation for searching for records in Trino. This method uses cursor based pagination.
   *
   * @param {object} search - The search condition for which records shall be fetched
   * @param {object} pagination - The parameters for pagination, which can be used to get a subset of the requested record set.
   * @param {BenignErrorReporter} benignErrorReporter can be used to generate the standard
   * @return {object} The set of records, possibly constrained by pagination, with full cursor information for all records
   */
  static async readAllCursor(search, order, pagination, benignErrorReporter) {
    //use default BenignErrorReporter if no BenignErrorReporter defined
    benignErrorReporter = errorHelper.getDefaultBenignErrorReporterIfUndef(
      benignErrorReporter
    );
    let isForwardPagination = helper.isForwardPagination(pagination);
    // build the whereOptions.
    let filter = prestoHelper.searchConditionsToTrino(search, definition);
    let newOrder = isForwardPagination
      ? order
      : helper.reverseOrderConditions(order);
    // depending on the direction build the order object
    let sort = prestoHelper.orderConditionsToTrino(
      newOrder,
      this.idAttribute(),
      isForwardPagination
    );
    let orderFields = newOrder ? newOrder.map((x) => x.field) : [];
    // extend the filter for the given order and cursor
    filter = prestoHelper.cursorPaginationArgumentsToTrino(
      pagination,
      sort,
      filter,
      orderFields,
      this.idAttribute(),
      definition.attributes
    );

    // add +1 to the LIMIT to get information about following pages.
    let limit;
    if (pagination){
      limit = helper.isNotUndefinedAndNotNull(pagination.first)
        ? pagination.first + 1
        : helper.isNotUndefinedAndNotNull(pagination.last)
        ? pagination.last + 1
        : undefined;
    }

    let query = `SELECT * FROM <%- namePl -%> ${filter} ${sort}`;
    query += limit ? ` LIMIT ${limit}` : '';
    let result = [];

    const client = await this.storageHandler;
    result = await prestoHelper.queryData(query, client);

    result = <%- nameLc -%>.postReadCast(result);
    // validationCheck after read
    result = await validatorUtil.bulkValidateData(
      "validateAfterRead",
      this,
      result,
      benignErrorReporter
    );
    // get the first record (if exists) in the opposite direction to determine pageInfo.
    // if no cursor was given there is no need for an extra query as the results will start at the first (or last) page.
    let oppResult = [];
    if (pagination && (pagination.after || pagination.before)) {
      // reverse the pagination Arguement. after -> before; set first/last to 0, so LIMIT 1 is executed in the reverse Search
      let oppPagination = helper.reversePaginationArgument({
        ...pagination,
        includeCursor: false,
      });
      let oppForwardPagination = helper.isForwardPagination(oppPagination);
      // build the filter object.
      let oppFilter = prestoHelper.searchConditionsToTrino(search, definition);

      let oppOrder = oppForwardPagination
        ? order
        : helper.reverseOrderConditions(order);
      // depending on the direction build the order object
      let oppSort = prestoHelper.orderConditionsToTrino(
        oppOrder,
        this.idAttribute(),
        oppForwardPagination
      );
      let oppOrderFields = oppOrder ? oppOrder.map((x) => x.field) : [];
      // extend the filter for the given order and cursor
      oppFilter = prestoHelper.cursorPaginationArgumentsToTrino(
        oppPagination,
        oppSort,
        oppFilter,
        oppOrderFields,
        this.idAttribute(),
        definition.attributes
      );
      // add +1 to the LIMIT to get information about following pages.
      let oppLimit;
      if (pagination){
        oppLimit = helper.isNotUndefinedAndNotNull(oppPagination.first)
          ? oppPagination.first + 1
          : helper.isNotUndefinedAndNotNull(oppPagination.last)
          ? oppPagination.last + 1
          : undefined;
      }
      query = `SELECT * FROM <%- namePl -%> ${oppFilter} ${oppSort}`;
      query += oppLimit ? ` LIMIT ${limit}` : '';
      oppResult = await prestoHelper.queryData(query, client);
      oppResult = <%- nameLc -%>.postReadCast(oppResult);
    }

    // build the graphql Connection Object
    result = result.map((res) => {
      return new <%- nameLc -%>(res);
    });
    let edges = result.map((res) => {
      return {
        node: res,
        cursor: res.base64Encode(),
      };
    });
    const pageInfo = helper.buildPageInfo(edges, oppResult, pagination);
    return { edges, pageInfo, <%- namePl -%>: edges.map((edge) => edge.node) };
  }

  /**
   * addOne - Not implemented for Trino.
   */
  static async addOne(input) {
    throw new Error("Not supported by Trino");
  }

  /**
   * deleteOne - Delete the whole file.
   */
  static async deleteOne(id) {
    throw new Error("Not supported by Trino");
  }

  /**
   * updateOne - Not implemented for Trino.
   */
  static async updateOne(input) {
    throw new Error("Not supported by Trino");
  }

  /**
   * bulkAddCsv - Add records from csv file
   *
   * @param  {object} context - contextual information, e.g. csv file, record delimiter and column names.
   */
  static async bulkAddCsv(context) {
    throw new Error("Not supported by Trino");
  }
  /**
   * csvTableTemplate - Allows the user to download a template in CSV format with the
   * properties and types of this model.
   *
   * @param {BenignErrorReporter} benignErrorReporter can be used to generate the standard
   * GraphQL output {error: ..., data: ...}. If the function reportError of the benignErrorReporter
   * is invoked, the server will include any so reported errors in the final response, i.e. the
   * GraphQL response will have a non empty errors property.
   */
  static async csvTableTemplate(benignErrorReporter) {
    return helper.csvTableTemplate(definition);
  }

  /**
   * idAttribute - Check whether an attribute "internalId" is given in the JSON model. If not the standard "id" is used instead.
   *
   * @return {type} Name of the attribute that functions as an internalId
   */

  static idAttribute() {
    return <%- nameLc -%>.definition.id.name;
  }

  /**
   * idAttributeType - Return the Type of the internalId.
   *
   * @return {type} Type given in the JSON model
   */

  static idAttributeType() {
    return <%- nameLc -%>.definition.id.type;
  }

  /**
   * getIdValue - Get the value of the idAttribute ("id", or "internalId") for an instance of <%- nameLc -%>.
   *
   * @return {type} id value
   */

  getIdValue() {
    return this[<%- nameLc -%>.idAttribute()];
  }

  /**
   * definition - Getter for the attribute 'definition'
   * @return {string} the definition string
   */
  static get definition() {
    return definition;
  }

  /**
   * base64Decode - Decode a base 64 String to UTF-8.
   * @param {string} cursor - The cursor to be decoded into the record, given in base 64
   * @return {string} The stringified object in UTF-8 format
   */
  static base64Decode(cursor) {
    return Buffer.from(cursor, "base64").toString("utf-8");
  }

  /**
   * base64Encode - Encode  <%- nameLc -%> to a base 64 String
   *
   * @return {string} The <%- nameLc -%> object, encoded in a base 64 String
   */
  base64Encode() {
    return Buffer.from(JSON.stringify(this.stripAssociations())).toString(
      "base64"
    );
  }

  /**
   * stripAssociations - Instant method for getting all attributes of <%- nameLc -%>.
   *
   * @return {object} The attributes of <%- nameLc -%> in object form
   */
  stripAssociations() {
    let attributes = Object.keys(<%- nameLc -%>.definition.attributes);
    let data_values = _.pick(this, attributes);
    return data_values;
  }

  /**
   * externalIdsArray - Get all attributes of <%- nameLc -%> that are marked as external IDs.
   *
   * @return {Array<String>} An array of all attributes of <%- nameLc -%> that are marked as external IDs
   */
  static externalIdsArray() {
    let externalIds = [];
    if (definition.externalIds) {
      externalIds = definition.externalIds;
    }

    return externalIds;
  }

  /**
   * externalIdsObject - Get all external IDs of <%- nameLc -%>.
   *
   * @return {object} An object that has the names of the external IDs as keys and their types as values
   */
  static externalIdsObject() {
    return {};
  }
};

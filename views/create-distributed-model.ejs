const _ = require('lodash');
const path = require('path');
const adapters = require('../adapters/index');
const globals = require('../../config/globals');
const helper = require('../../utils/helper');
const models = require(path.join(__dirname, '..', 'index.js'));
const validatorUtil = require('../../utils/validatorUtil');
const errorHelper = require('../../utils/errors');


const definition = <%- definition -%>;

let registry = [ <%- registry.map( x => '"'+x+'"') -%> ];

module.exports = class <%- name -%>{

  /**
   * constructor - Creates an instance of the model
   *
   * @param  {obejct} input    Data for the new instances. Input for each field of the model.
   */

  constructor({<%- idAttribute -%> <%for(var key in attributes){-%>,<%=key-%><%}-%><% if (cassandraRestrictions) { -%>, toke<% } %>}){
      this.<%- idAttribute -%> = <%- idAttribute -%>;
       <%for(var key in attributes){-%>
         this.<%=key-%> =<%=key-%>;
        <%}-%>
        <% if (cassandraRestrictions) { %>this.toke = toke;<% } -%>
  }

  static get name(){
    return "<%- nameLc -%>";
  }

  /**
   * registeredAdapters - Returns an object which has a key for each
   * adapter on adapter/index.js. Each key of the object will have
   *
   * @return {string}     baseUrl from request.
   */
  static get registeredAdapters() {
    return [<%- registry.map( x => '"'+x+'"') %>].reduce( (a,c) => { a[c] = adapters[c]; return a; }, {} );
  }

  static adapterForIri(iri) {
    let responsibleAdapter = registry.filter(adapter => adapters[adapter].recognizeId(iri));
    if (responsibleAdapter.length > 1) {
      throw new Error("IRI has no unique match");
    } else if (responsibleAdapter.length === 0) {
      throw new Error("IRI has no match WS");
    }
    return responsibleAdapter[0];
  }

  static readById(id, benignErrorReporter) {
    if(id!==null){
      let responsibleAdapter = registry.filter( adapter => adapters[adapter].recognizeId(id));

      if(responsibleAdapter.length > 1 ){
        throw new Error("IRI has no unique match");
      }else if(responsibleAdapter.length === 0){
        throw new Error("IRI has no match WS");
      }

      //use default BenignErrorReporter if no BenignErrorReporter defined
      benignErrorReporter = errorHelper.getDefaultBenignErrorReporterIfUndef( benignErrorReporter );
      return adapters[responsibleAdapter[0]].readById(id, benignErrorReporter).then(result => {
        let item = new <%- name -%>(result);
        return validatorUtil.ifHasValidatorFunctionInvoke('validateAfterRead', this, item)
            .then((valSuccess) => {
              return item;
            });
      });
    }
  }

  static countRecords(search, authorizedAdapters, benignErrorReporter, searchAuthorizedAdapters){
    let authAdapters = [];
    /**
     * Differentiated cases:
     *    if authorizedAdapters is defined:
     *      - called from resolver.
     *      - authorizedAdapters will no be modified.
     *
     *    if authorizedAdapters is not defined:
     *      - called internally
     *      - authorizedAdapters will be set to registered adapters.
     */
    if(authorizedAdapters === undefined) {
      authAdapters = Object.values(this.registeredAdapters);
    } else {
      authAdapters = Array.from(authorizedAdapters)
    }

    let searchAuthAdapters = [];

    if (helper.isNotUndefinedAndNotNull(searchAuthorizedAdapters)) {
      searchAuthAdapters = Array.from(searchAuthorizedAdapters).filter(adapter => adapter.adapterType === 'cassandra-adapter').map(adapter => adapter.adapterName);
    }

    //use default BenignErrorReporter if no BenignErrorReporter defined
    benignErrorReporter = errorHelper.getDefaultBenignErrorReporterIfUndef( benignErrorReporter );

    let promises = authAdapters.map( adapter => {
      /**
       * Differentiated cases:
       *   sql-adapter:
       *      resolve with current parameters.
       *
       *   ddm-adapter:
       *   cenzontle-webservice-adapter:
       *   generic-adapter:
       *      add exclusions to search.excludeAdapterNames parameter.
       */
      switch(adapter.adapterType) {
        case 'ddm-adapter':
        case 'generic-adapter':
          let nsearch = helper.addExclusions(search, adapter.adapterName, Object.values(this.registeredAdapters));
          return adapter.countRecords(nsearch, benignErrorReporter);

        case 'sql-adapter':
        case 'cenzontle-webservice-adapter':
        case 'cassandra-adapter':
          return adapter.countRecords(search, benignErrorReporter, searchAuthAdapters.includes(adapter.adapterName));

        case 'default':
          throw new Error(`Adapter type: '${adapter.adapterType}' is not supported`);
      }
    });

    return Promise.allSettled(promises).then(results => {
        return results.reduce((total, current) => {
            //check if current is Error
            if (current.status === 'rejected') {
                benignErrorReporter.reportError(current.reason);
            }
            //check current result
            else if (current.status === 'fulfilled') {
                total += current.value;
            }
            return total;
        }, 0 );
    });
  }

  static readAllCursor(search, order, pagination, authorizedAdapters, benignErrorReporter, searchAuthorizedAdapters) {
    let authAdapters = [];
    /**
     * Differentiated cases:
     *    if authorizedAdapters is defined:
     *      - called from resolver.
     *      - authorizedAdapters will no be modified.
     *
     *    if authorizedAdapters is not defined:
     *      - called internally
     *      - authorizedAdapters will be set to registered adapters.
     */
    if(authorizedAdapters === undefined) {
      authAdapters = Object.values(this.registeredAdapters);
    } else {
      authAdapters = Array.from(authorizedAdapters)
    }

    let searchAuthAdapters = [];

    if (helper.isNotUndefinedAndNotNull(searchAuthorizedAdapters)) {
      searchAuthAdapters = Array.from(searchAuthorizedAdapters).filter(adapter => adapter.adapterType === 'cassandra-adapter').map(adapter => adapter.adapterName);
    }

    <% if (!cassandraRestrictions) { %>
    //check valid pagination arguments
    let argsValid = (pagination === undefined) || (pagination.first && !pagination.before && !pagination.last) || (pagination.last && !pagination.after && !pagination.first);
    if (!argsValid) {
      throw new Error('Illegal cursor based pagination arguments. Use either "first" and optionally "after", or "last" and optionally "before"!');
    }
    <% } %>

    //use default BenignErrorReporter if no BenignErrorReporter defined
    benignErrorReporter = errorHelper.getDefaultBenignErrorReporterIfUndef( benignErrorReporter );


    let isForwardPagination = !pagination || !(pagination.last != undefined);
    let promises = authAdapters.map(adapter => {
      /**
       * Differentiated cases:
       *   sql-adapter:
       *      resolve with current parameters.
       *
       *   ddm-adapter:
       *   cenzontle-webservice-adapter:
       *   generic-adapter:
       *      add exclusions to search.excludeAdapterNames parameter.
       */
      switch(adapter.adapterType) {
        case 'ddm-adapter':
          let nsearch = helper.addExclusions(search, adapter.adapterName, Object.values(this.registeredAdapters));
          return adapter.readAllCursor(nsearch, <%if (!cassandraRestrictions) { %>order, <% } %>pagination, benignErrorReporter);

        case 'generic-adapter':
        case 'sql-adapter':
        case 'cenzontle-webservice-adapter':
          return adapter.readAllCursor(search, order, pagination, benignErrorReporter);

        case 'cassandra-adapter':
          return adapter.readAllCursor(search, pagination, searchAuthAdapters.includes(adapter.adapterName));

        default:
          throw new Error(`Adapter type '${adapter.adapterType}' is not supported`);
      }
    });
    let someHasNextPage = false;
    <% if (!cassandraRestrictions) { %>let someHasPreviousPage = false;<% } %>
    return Promise.allSettled(promises)
    //phase 1: reduce
    .then( results => {
      return results.reduce( (total, current)=> {
        //check if current is Error
        if (current.status === 'rejected') {
            benignErrorReporter.reportError(current.reason);
        }
        //check current
        else if (current.status === 'fulfilled') {
          if (current.value && current.value.pageInfo && current.value.edges) {
              someHasNextPage |= current.value.pageInfo.hasNextPage;
              <% if (!cassandraRestrictions) { %>someHasPreviousPage |= current.value.pageInfo.hasPreviousPage;<% } %>
              total = total.concat(current.value.edges.map(e => e.node));
          }
        }
        return total;
      }, []);
    })
    //phase 2: order & paginate
    .then( nodes => {

      <%if (!cassandraRestrictions) { %>if(order === undefined ){ order = [{field:"<%- idAttribute -%>", order:'ASC'}]; }<% } %>
      if(pagination === undefined ){ pagination = { <% if (cassandraRestrictions) { %>limit<% } else { %>first<% } %> : Math.min(globals.LIMIT_RECORDS, nodes.length)  }}

      <% if (cassandraRestrictions) { %>
      let ordered_records = helper.orderRecordsWithCassandra(nodes, '<%- idAttribute -%>');
      let paginated_records = helper.paginateRecordsCursor(ordered_records, pagination.limit);
      let hasNextPage = ordered_records.length > pagination.limit || someHasNextPage;
      let graphQLConnection = helper.toGraphQLCassandraConnectionObject(paginated_records, this, hasNextPage);
      return graphQLConnection;
      <% } else { %>
      let ordered_records = helper.orderRecords(nodes, order);
      let paginated_records = [];

      if(isForwardPagination){
        paginated_records = helper.paginateRecordsCursor(ordered_records, pagination.first);
      } else {
        paginated_records = helper.paginateRecordsBefore(ordered_records, pagination.last);
      }

      let hasNextPage = ordered_records.length > pagination.first || someHasNextPage;
      let hasPreviousPage = ordered_records.length > pagination.last || someHasPreviousPage;

      let graphQLConnection = helper.toGraphQLConnectionObject(paginated_records, this, hasNextPage, hasPreviousPage);
      return graphQLConnection;
      <% } %>
    });
  }

  static get definition(){
    <%if (cassandraRestrictions) { -%>
    let def = definition;
    def.attributes.toke = 'String';
    return def;
    <% } else { -%>
    return definition;
    <% } -%>
  }

  static base64Decode(cursor){
    return Buffer.from(cursor, 'base64').toString('utf-8');
  }

  base64Enconde(){
    return Buffer.from(JSON.stringify(this.stripAssociations())).toString('base64');
  }

  stripAssociations(){
    let attributes = Object.keys(<%- name -%>.definition.attributes);
    <%if( defaultId ){-%>attributes.push('<%- idAttribute -%>'); <%}-%>
    let data_values = _.pick(this, attributes);
    return data_values;
  }

  /**
   * idAttribute - Check whether an attribute "internalId" is given in the JSON model. If not the standard "id" is used instead.
   *
   * @return {type} Name of the attribute that functions as an internalId
   */

  static idAttribute() {
    let internalId = <%- name -%>.definition.id.name;
    return internalId;
  }

  /**
   * idAttributeType - Return the Type of the internalId.
   *
   * @return {type} Type given in the JSON model
   */

  static idAttributeType() {
    return <%- name -%>.definition.id.type;
  }

  /**
   * getIdValue - Get the value of the idAttribute ("id", or "internalId") for an instance of <%- name -%>.
   *
   * @return {type} id value
   */

  getIdValue() {
    return this[<%- name -%>.idAttribute()]
  }

  static assertInputHasId(input) {
    if (! input.<%- idAttribute -%>) {
      throw new Error(`Illegal argument. Provided input requires attribute '<%- idAttribute -%>'.`);
    }
    return true;
  }

  static addOne(input, benignErrorReporter) {
    this.assertInputHasId(input);
    return validatorUtil.ifHasValidatorFunctionInvoke('validateForCreate', this, input)
        .then(async (valSuccess) => {
        let responsibleAdapter = this.adapterForIri(input.<%- idAttribute -%>);
        //use default BenignErrorReporter if no BenignErrorReporter defined
        benignErrorReporter = errorHelper.getDefaultBenignErrorReporterIfUndef( benignErrorReporter );
        return adapters[responsibleAdapter].addOne(input, benignErrorReporter).then(result => new <%- name -%>(result));
      });
  }

  static async deleteOne(id, benignErrorReporter) {
    await validatorUtil.ifHasValidatorFunctionInvoke('validateForDelete', this, id);
    let responsibleAdapter = this.adapterForIri(id);
    //use default BenignErrorReporter if no BenignErrorReporter defined
    benignErrorReporter = errorHelper.getDefaultBenignErrorReporterIfUndef( benignErrorReporter );
    return adapters[responsibleAdapter].deleteOne(id, benignErrorReporter);
  }

  static updateOne(input, benignErrorReporter) {
    this.assertInputHasId(input);
    return validatorUtil.ifHasValidatorFunctionInvoke('validateForUpdate', this, input)
        .then(async (valSuccess) => {
        let responsibleAdapter = this.adapterForIri(input.<%- idAttribute -%>);
        //use default BenignErrorReporter if no BenignErrorReporter defined
        benignErrorReporter = errorHelper.getDefaultBenignErrorReporterIfUndef( benignErrorReporter );
        return adapters[responsibleAdapter].updateOne(input, benignErrorReporter).then(result => new <%- name -%>(result));
    });
  }

  static bulkAddCsv(context) {
    throw new Error("<%- name -%>.bulkAddCsv is not implemented.")
  }

  /**
   * csvTableTemplate - Allows the user to download a template in CSV format with the
   * properties and types of this model.
   *
   * @param {BenignErrorReporter} benignErrorReporter can be used to generate the standard
   * GraphQL output {error: ..., data: ...}. If the function reportError of the benignErrorReporter
   * is invoked, the server will include any so reported errors in the final response, i.e. the
   * GraphQL response will have a non empty errors property.
   */
  static async csvTableTemplate(benignErrorReporter){
      return helper.csvTableTemplate(definition);
  }

<%# generic_to_one -%>
  <% associations_temp = associationsArguments["generic_to_one"]-%>
  <% for(let i=0; i < associations_temp.length; i++){ -%>

    /**
     * <%=associations_temp[i].name%>Impl - Return associated record.
     *
     * @param  {object} search      Search argument to match the associated record.
     * @param  {object} context     Provided to every resolver holds contextual information like the
     * resquest query and user info.
     * @param {BenignErrorReporter} benignErrorReporter can be used to generate the standard
     * GraphQL output {error: ..., data: ...}. If the function reportError of the benignErrorReporter
     * is invoked, the server will include any so reported errors in the final response, i.e. the
     * GraphQL response will have a non empty errors property.
     * @return {type}   Associated record.
     */
    async <%=associations_temp[i].name%>Impl({search}, context, benignErrorReporter){
      /*
      YOUR CODE GOES HERE
      */
      throw new Error('<%=associations_temp[i].name%>Impl() is not implemented');
    }
  <%}-%>
<%# generic_to_many -%>
  <% associations_temp = associationsArguments["generic_to_many"]-%>
  <% for(let i=0; i < associations_temp.length; i++){ -%>

    /**
     * <%=associations_temp[i].name%>FilterImpl - Return certain number, specified in pagination argument,
     * of records associated with the current instance, this records should also holds the condition of search
     * argument, all of them sorted as specified by the order argument.
     *
     * @param  {object} search      Search argument for filtering associated records.
     * @param  {array} order        Type of sorting (ASC, DESC) for each field.
     * @param  {object} pagination  Offset and limit to get the records from and to respectively.
     * @param  {object} context     Provided to every resolver holds contextual information like the
     * resquest query and user info.
     * @param {BenignErrorReporter} benignErrorReporter can be used to generate the standard
     * GraphQL output {error: ..., data: ...}. If the function reportError of the benignErrorReporter
     * is invoked, the server will include any so reported errors in the final response, i.e. the
     * GraphQL response will have a non empty errors property.
     * @return {array}    Array of associated records holding conditions specified by search, order and
     * pagination argument.
     */
    async <%=associations_temp[i].name%>FilterImpl({search,order,pagination}, context, benignErrorReporter){
      /*
      YOUR CODE GOES HERE
      */
      throw new Error('<%=associations_temp[i].name%>FilterImpl() is not implemented');
    }

    /**
     * <%=associations_temp[i].name%>ConnectionImpl - Return certain number, specified in pagination argument,
     * of records associated with the current instance, this records should also holds the condition of search
     * argument, all of them sorted as specified by the order argument.
     *
     * @param  {object} search      Search argument for filtering associated records.
     * @param  {array} order        Type of sorting (ASC, DESC) for each field.
     * @param  {object} pagination  Cursor and first (indicatig the number of records to retrieve)
     * arguments to apply cursor-based pagination.
     * @param  {object} context     Provided to every resolver holds contextual information like the
     * resquest query and user info.
     * @param {BenignErrorReporter} benignErrorReporter can be used to generate the standard
     * GraphQL output {error: ..., data: ...}. If the function reportError of the benignErrorReporter
     * is invoked, the server will include any so reported errors in the final response, i.e. the
     * GraphQL response will have a non empty errors property.
     * @return {array}    Array of records as grapqhql connections holding conditions specified by search,
     * order and pagination argument.
     */
    async <%=associations_temp[i].name%>ConnectionImpl ({search,order,pagination}, context, benignErrorReporter){
      /*
      YOUR CODE GOES HERE
      */
      throw new Error('<%=associations_temp[i].name%>ConnectionImpl() is not implemented');
    }

    /**
     * countFiltered<%=associations_temp[i].name_cp%>Impl - Count number of associated records that
     * holds the conditions specified in the search argument.
     *
     * @param  {object} {search}    Search argument for filtering associated records.
     * @param  {object} context     Provided to every resolver holds contextual information like the
     * resquest query and user info.
     * @param {BenignErrorReporter} benignErrorReporter can be used to generate the standard
     * GraphQL output {error: ..., data: ...}. If the function reportError of the benignErrorReporter
     * is invoked, the server will include any so reported errors in the final response, i.e. the
     * GraphQL response will have a non empty errors property.
     * @return {type}   Number of associated records that holds the conditions specified in the search
     * argument.
     */
    async countFiltered<%=associations_temp[i].name_cp%>Impl({search}, context, benignErrorReporter){
      /*
      YOUR CODE GOES HERE
      */
      throw new Error('countFiltered<%- associations_temp[i].name_cp %>Impl() is not implemented');
    }
  <%}-%>

  <%#
  /**
   * Add and remove methods for to-one association where the foreign key
   * is stored in this model. Also for generic-to-one and generic-to-many
   * associations.
   */
  -%>
  <%- include('./includes/create-ddm-models-fields-mutations', {op: "add"}); %>
  <%- include('./includes/create-ddm-models-fields-mutations', {op: "remove"}); %>
  <%- include('./includes/create-models-fieldMutations-generic-associations', {op: "add"}); %>
  <%- include('./includes/create-models-fieldMutations-generic-associations', {op: "remove"}); %>

}

const axios_general = require('axios');
const globals = require('../../config/globals');
const validatorUtil = require('../../utils/validatorUtil');
const errorHelper = require('../../utils/errors');
const helper = require('../../utils/helper');

let axios = axios_general.create();
axios.defaults.timeout = globals.MAX_TIME_OUT;

const remoteVocenURL = "<%- url -%>";
const iriRegex = new RegExp('<%- regex -%>');

module.exports = class <%- adapterName -%>{

  static get adapterName(){
    return '<%- adapterName -%>';
  }

  static get adapterType(){
    return '<%- storageType -%>';
  }

  static recognizeId(iri){
    return iriRegex.test(iri);
  }

  static async readById(iri, benignErrorReporter){
    let query = `
          query
            readOne<%- nameCp %>
            {
              readOne<%- nameCp -%>(<%- idAttribute -%>:"${iri}")
              {
                <%- idAttribute -%> <%for(var key in attributes){ %>
                <%= key %> <%}%>
              }
            }`;

      try {
        // Send an HTTP request to the remote server
        let response = await axios.post(remoteVocenURL, {query:query});
        //check if remote service returned benign Errors in the response and add them to the benignErrorReporter
        if(helper.isNonEmptyArray(response.data.errors)) {
          benignErrorReporter.reportError(errorHelper.handleRemoteErrors(response.data.errors, remoteVocenURL));
        }
        // STATUS-CODE is 200
        // NO ERROR as such has been detected by the server (Express)
        // check if data was send
        if (response && response.data && response.data.data) {
          return response.data.data.readOne<%- nameCp -%>;
        } else {
          throw new Error(`Invalid response from remote zendro-server: ${remoteVocenURL}`);
        }
      } catch(error) {
        //handle caught errors
        errorHelper.handleCaughtErrorAndBenignErrors(error, benignErrorReporter, remoteVocenURL);
      }
  }

  static async countRecords(search, benignErrorReporter){
    let query = `
      query count<%- namePlCp -%>($search: search<%- nameCp -%>Input){
        count<%- namePlCp -%>(search: $search)
      }`

      try {
        // Send an HTTP request to the remote server
        let response = await axios.post(remoteVocenURL, {query:query,variables: {search: search}});

        //check if remote service returned benign Errors in the response and add them to the benignErrorReporter
        if(helper.isNonEmptyArray(response.data.errors)) {
          benignErrorReporter.reportError(errorHelper.handleRemoteErrors(response.data.errors, remoteVocenURL));
        }
        // STATUS-CODE is 200
        // NO ERROR as such has been detected by the server (Express)
        // check if data was send
        if (response && response.data && response.data.data) {
          return response.data.data.count<%- namePlCp -%>;
        } else {
          throw new Error(`Invalid response from remote zendro-server: ${remoteVocenURL}`);
        }
      } catch(error) {
        //handle caught errors
        errorHelper.handleCaughtErrorAndBenignErrors(error, benignErrorReporter, remoteVocenURL);
      }

  }

  static async readAllCursor(search, order, pagination, benignErrorReporter){
    //check valid pagination arguments
    let argsValid = (pagination === undefined) || (pagination.first && !pagination.before && !pagination.last) || (pagination.last && !pagination.after && !pagination.first);
    if (!argsValid) {
      throw new Error('Illegal cursor based pagination arguments. Use either "first" and optionally "after", or "last" and optionally "before"!');
    }
    let query = `query <%- namePl -%>Connection($search: search<%- nameCp -%>Input $pagination: paginationCursorInput $order: [order<%- nameCp -%>Input]){
      <%- namePl -%>Connection(search:$search pagination:$pagination order:$order){ edges{cursor node{  <%- idAttribute -%> <%for(var key in attributes){-%> <%=key %>
        <%}-%>} } pageInfo{ startCursor endCursor hasPreviousPage hasNextPage } } }`

        try {
          // Send an HTTP request to the remote server
          let response = await axios.post(remoteVocenURL, {query:query, variables: {search: search, order:order, pagination: pagination}});
          //check if remote service returned benign Errors in the response and add them to the benignErrorReporter
          if(helper.isNonEmptyArray(response.data.errors)) {
            benignErrorReporter.reportError(errorHelper.handleRemoteErrors(response.data.errors, remoteVocenURL));
          }
          // STATUS-CODE is 200
          // NO ERROR as such has been detected by the server (Express)
          // check if data was send
          if(response && response.data && response.data.data) {
            return response.data.data.<%- namePl -%>Connection;
          } else {
            throw new Error(`Invalid response from remote zendro-server: ${remoteVocenURL}`);
          }
        } catch(error) {
          //handle caught errors
          errorHelper.handleCaughtErrorAndBenignErrors(error, benignErrorReporter, remoteVocenURL);
        }
  }

  static async addOne(input, benignErrorReporter){
      let query = `
          mutation add<%- nameCp _%>(
  <%if(!defaultId){-%>
            $<%=idAttribute%>:ID! <%}-%> <%for(var key in editableAttributes){%>
            $<%=key %>:<%= editableAttributes[key]%><%}-%>
          ){
            add<%- nameCp -%>(<%if(!defaultId){-%>
            <%=idAttribute %>:$<%= idAttribute%> <%}-%> <%for(var key in editableAttributes){%>
            <%=key %>:$<%= key%><%}-%>){
              <%- idAttribute -%>
  <%for(var key in attributes){-%>
              <%=key %>
  <%}-%>
            }
          }`;

      try {
        // Send an HTTP request to the remote server
        let response = await axios.post(remoteVocenURL, {query:query,variables: input});
        //check if remote service returned benign Errors in the response and add them to the benignErrorReporter
        if(helper.isNonEmptyArray(response.data.errors)) {
          benignErrorReporter.reportError(errorHelper.handleRemoteErrors(response.data.errors, remoteVocenURL));
        }
        if (response && response.data && response.data.data) {
          return response.data.data.add<%- nameCp -%>;
        } else {
          throw new Error(`Invalid response from remote zendro-server: ${remoteVocenURL}`);
        }
      } catch(error) {
        //handle caught errors
        errorHelper.handleCaughtErrorAndBenignErrors(error, benignErrorReporter, remoteVocenURL);
      }
  }

  static async deleteOne(id, benignErrorReporter){
    let query = `
          mutation
            delete<%- nameCp -%>{
              delete<%- nameCp -%>(
                <%- idAttribute -%>: "${id}" )}`;
    
   
    try {
      // Send an HTTP request to the remote server
      let response = await axios.post(remoteVocenURL, {query:query});
      //check if remote service returned benign Errors in the response and add them to the benignErrorReporter
      if(helper.isNonEmptyArray(response.data.errors)) {
        benignErrorReporter.reportError(errorHelper.handleRemoteErrors(response.data.errors, remoteVocenURL));
      }
      if (response && response.data && response.data.data) {
        return response.data.data.delete<%- nameCp -%>;
      } else {
        throw new Error(`Invalid response from remote zendro-server: ${remoteVocenURL}`);
      }
    } catch(error) {
      //handle caught errors
      errorHelper.handleCaughtErrorAndBenignErrors(error, benignErrorReporter, remoteVocenURL);
    }
  }

  static async updateOne(input, benignErrorReporter){
    let query = `
          mutation
            update<%- nameCp-%>(
              $<%- idAttribute -%>:ID! <%for(var key in editableAttributes){%>
              $<%=key %>:<%= editableAttributes[key]%> <%}-%>
            ){
              update<%- nameCp-%>(
                <%- idAttribute -%>:$<%- idAttribute -%> <%for(var key in editableAttributes){%>
                <%=key %>:$<%= key%> <%}-%>
              ){
                <%- idAttribute -%> <%for(var key in attributes){%>
                <%=key %> <%}%>
              }
            }`

   
    try {
      // Send an HTTP request to the remote server
      let response = await axios.post(remoteVocenURL, {query:query, variables:input});
      //check if remote service returned benign Errors in the response and add them to the benignErrorReporter
      if(helper.isNonEmptyArray(response.data.errors)) {
        benignErrorReporter.reportError(errorHelper.handleRemoteErrors(response.data.errors, remoteVocenURL));
      }
      if (response && response.data && response.data.data) {
        return response.data.data.update<%- nameCp -%>;
      } else {
        throw new Error(`Invalid response from remote zendro-server: ${remoteVocenURL}`);
      }
    } catch(error) {
      //handle caught errors
      errorHelper.handleCaughtErrorAndBenignErrors(error, benignErrorReporter, remoteVocenURL);
    }
  }


  <%#
  /**
   * Add and remove methods for to-one association where the foreign key
   * is stored in this model and therefore this adapter is the responsible to update the foreign key.
   */
  -%>
  <%- include('./includes/create-adapter-fields-mutations', {op: "add"}); %>
  <%- include('./includes/create-adapter-fields-mutations', {op: "remove"}); %>


  static bulkAddCsv(context) {
    throw new Error("<%- name -%>.bulkAddCsv is not implemented.")
  }

  static async csvTableTemplate(benignErrorReporter){
    let query = `query { csvTableTemplate<%- nameCp-%> }`;

    try {
      let response = await axios.post(remoteVocenURL, {query:query});
      //check if remote service returned benign Errors in the response and add them to the benignErrorReporter
      if(helper.isNonEmptyArray(response.data.errors)) {
        benignErrorReporter.reportError(errorHelper.handleRemoteErrors(response.data.errors, remoteVocenURL));
      }
      return response.data.data.csvTableTemplate<%- nameCp-%>;
    } catch(error) {
      //handle caught errors
      errorHelper.handleCaughtErrorAndBenignErrors(error, benignErrorReporter, remoteVocenURL);
    }
  }
  
}
